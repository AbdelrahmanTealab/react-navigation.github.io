"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[78680],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return h}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=u(e,["components","mdxType","originalType","parentName"]),p=c(t),f=a,h=p["".concat(s,".").concat(f)]||p[f]||d[f]||o;return t?r.createElement(h,i(i({ref:n},l),{},{components:t})):r.createElement(h,i({ref:n},l))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=f;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u[p]="string"==typeof e?e:a,i[1]=u;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},85162:function(e,n,t){t.d(n,{Z:function(){return i}});var r=t(67294),a=t(86010),o={tabItem:"tabItem_Ymn6"};function i(e){var n=e.children,t=e.hidden,i=e.className;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,i),hidden:t},n)}},74866:function(e,n,t){t.d(n,{Z:function(){return k}});var r=t(83117),a=t(67294),o=t(86010),i=t(12466),u=t(16550),s=t(91980),c=t(67392),l=t(50012);function p(e){return function(e){return a.Children.map(e,(function(e){if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes,default:n.default}}))}function d(e){var n=e.values,t=e.children;return(0,a.useMemo)((function(){var e=null!=n?n:p(t);return function(e){var n=(0,c.l)(e,(function(e,n){return e.value===n.value}));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function f(e){var n=e.value;return e.tabValues.some((function(e){return e.value===n}))}function h(e){var n=e.queryString,t=void 0!==n&&n,r=e.groupId,o=(0,u.k6)(),i=function(e){var n=e.queryString,t=void 0!==n&&n,r=e.groupId;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=r?r:null}({queryString:t,groupId:r});return[(0,s._X)(i),(0,a.useCallback)((function(e){if(i){var n=new URLSearchParams(o.location.search);n.set(i,e),o.replace(Object.assign({},o.location,{search:n.toString()}))}}),[i,o])]}function m(e){var n,t,r,o,i=e.defaultValue,u=e.queryString,s=void 0!==u&&u,c=e.groupId,p=d(e),m=(0,a.useState)((function(){return function(e){var n,t=e.defaultValue,r=e.tabValues;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}var a=null!=(n=r.find((function(e){return e.default})))?n:r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:i,tabValues:p})})),v=m[0],g=m[1],b=h({queryString:s,groupId:c}),w=b[0],y=b[1],k=(n=function(e){return e?"docusaurus.tab."+e:null}({groupId:c}.groupId),t=(0,l.Nk)(n),r=t[0],o=t[1],[r,(0,a.useCallback)((function(e){n&&o.set(e)}),[n,o])]),N=k[0],T=k[1],x=function(){var e=null!=w?w:N;return f({value:e,tabValues:p})?e:null}();return(0,a.useLayoutEffect)((function(){x&&g(x)}),[x]),{selectedValue:v,selectValue:(0,a.useCallback)((function(e){if(!f({value:e,tabValues:p}))throw new Error("Can't select invalid tab value="+e);g(e),y(e),T(e)}),[y,T,p]),tabValues:p}}var v=t(72389),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){var n=e.className,t=e.block,u=e.selectedValue,s=e.selectValue,c=e.tabValues,l=[],p=(0,i.o5)().blockElementScrollPositionUntilNextRender,d=function(e){var n=e.currentTarget,t=l.indexOf(n),r=c[t].value;r!==u&&(p(n),s(r))},f=function(e){var n,t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":var r,a=l.indexOf(e.currentTarget)+1;t=null!=(r=l[a])?r:l[0];break;case"ArrowLeft":var o,i=l.indexOf(e.currentTarget)-1;t=null!=(o=l[i])?o:l[l.length-1]}null==(n=t)||n.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n)},c.map((function(e){var n=e.value,t=e.label,i=e.attributes;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:u===n?0:-1,"aria-selected":u===n,key:n,ref:function(e){return l.push(e)},onKeyDown:f,onClick:d},i,{className:(0,o.Z)("tabs__item",g.tabItem,null==i?void 0:i.className,{"tabs__item--active":u===n})}),null!=t?t:n)})))}function w(e){var n=e.lazy,t=e.children,r=e.selectedValue;if(t=Array.isArray(t)?t:[t],n){var o=t.find((function(e){return e.props.value===r}));return o?(0,a.cloneElement)(o,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},t.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})})))}function y(e){var n=m(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",g.tabList)},a.createElement(b,(0,r.Z)({},e,n)),a.createElement(w,(0,r.Z)({},e,n)))}function k(e){var n=(0,v.Z)();return a.createElement(y,(0,r.Z)({key:String(n)},e))}},93807:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return u},metadata:function(){return c},toc:function(){return p}});var r=t(83117),a=t(80102),o=(t(67294),t(3905)),i=(t(74866),t(85162),["components"]),u={id:"function-after-focusing-screen",title:"Call a function when focused screen changes",sidebar_label:"Call a function when focused screen changes"},s=void 0,c={unversionedId:"function-after-focusing-screen",id:"version-4.x/function-after-focusing-screen",title:"Call a function when focused screen changes",description:"In this guide we will call a function on screen focusing. This is useful for making additional API calls when a user revisits a particular screen in a Tab Navigator, or to track user events as they tap around our app.",source:"@site/versioned_docs/version-4.x/function-after-focusing-screen.md",sourceDirName:".",slug:"/function-after-focusing-screen",permalink:"/docs/4.x/function-after-focusing-screen",draft:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-4.x/function-after-focusing-screen.md",tags:[],version:"4.x",frontMatter:{id:"function-after-focusing-screen",title:"Call a function when focused screen changes",sidebar_label:"Call a function when focused screen changes"},sidebar:"version-4.x-docs",previous:{title:"Web support",permalink:"/docs/4.x/web-support"},next:{title:"Optimize memory usage and performance",permalink:"/docs/4.x/react-native-screens"}},l={},p=[{value:"Triggering an action with the <code>withNavigationFocus</code> higher order component",id:"triggering-an-action-with-the-withnavigationfocus-higher-order-component",level:2},{value:"Example",id:"example",level:3},{value:"Triggering an action with a <code>&#39;didFocus&#39;</code> event listener",id:"triggering-an-action-with-a-didfocus-event-listener",level:2},{value:"Example",id:"example-1",level:3}],d={toc:p},f="wrapper";function h(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)(f,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"In this guide we will call a function on screen focusing. This is useful for making additional API calls when a user revisits a particular screen in a Tab Navigator, or to track user events as they tap around our app."),(0,o.kt)("p",null,"There are two approaches available to us:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Using the ",(0,o.kt)("inlineCode",{parentName:"li"},"withNavigationFocus")," higher order component provided by react-navigation."),(0,o.kt)("li",{parentName:"ol"},"Listening to the ",(0,o.kt)("inlineCode",{parentName:"li"},"'didFocus'")," event with an event listener.")),(0,o.kt)("h2",{id:"triggering-an-action-with-the-withnavigationfocus-higher-order-component"},"Triggering an action with the ",(0,o.kt)("inlineCode",{parentName:"h2"},"withNavigationFocus")," higher order component"),(0,o.kt)("p",null,"react-navigation provides a ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/higher-order-components.html"},"higher order component")," that passes an ",(0,o.kt)("inlineCode",{parentName:"p"},"isFocused")," prop to our component, along with the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation")," object we'd normally get with ",(0,o.kt)("inlineCode",{parentName:"p"},"withNavigation"),"."),(0,o.kt)("p",null,"When the ",(0,o.kt)("inlineCode",{parentName:"p"},"isFocused")," prop is passed to our component, it will pass ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," when the screen is focused and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," when our component is no longer focused. This enables us to call actions on a user entering or leaving a screen. This is particularly handy when we are trying to stop something when the page is unfocused, like stopping a video or audio file from playing, or stopping the tracking of a user's location."),(0,o.kt)("p",null,"Since ",(0,o.kt)("inlineCode",{parentName:"p"},"withNavigationFocus")," passes a prop on every focus change, it will cause our component to re-render when we focus and unfocus a screen. Using this higher order component may introduce unnecessary component re-renders as a screen comes in and out of focus. This could cause issues depending on the type of action we're calling on focusing."),(0,o.kt)("p",null,"For instance, if we are attempting to make an API call on focus to fetch some data, we only want to fetch data when the component is focused and not when the component becomes unfocused. To prevent extra component re-renders, we could write some logic in ",(0,o.kt)("inlineCode",{parentName:"p"},"shouldComponentUpdate")," to control when the component renders itself, however we may be better off using the event listener method detailed below. The event listener will only call an action and render the component when the screen is focused and will do nothing when a screen becomes unfocused."),(0,o.kt)("h3",{id:"example"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React, { Component } from 'react';\nimport { View } from 'react-native';\nimport { withNavigationFocus } from 'react-navigation';\n\nclass TabScreen extends Component {\n  componentDidUpdate(prevProps) {\n    if (prevProps.isFocused !== this.props.isFocused) {\n      // Use the `this.props.isFocused` boolean\n      // Call any action\n    }\n  }\n\n  render() {\n    return <View />;\n  }\n}\n\n// withNavigationFocus returns a component that wraps TabScreen and passes\n// in the navigation prop\nexport default withNavigationFocus(TabScreen);\n")),(0,o.kt)("p",null,"This example is also documented in the ",(0,o.kt)("a",{parentName:"p",href:"/docs/4.x/with-navigation-focus"},(0,o.kt)("inlineCode",{parentName:"a"},"withNavigationFocus")," API documentation"),"."),(0,o.kt)("h2",{id:"triggering-an-action-with-a-didfocus-event-listener"},"Triggering an action with a ",(0,o.kt)("inlineCode",{parentName:"h2"},"'didFocus'")," event listener"),(0,o.kt)("p",null,"We can also listen to the ",(0,o.kt)("inlineCode",{parentName:"p"},"'didFocus'")," event with an event listener. After setting up an event listener, we must also stop listening to the event when the screen is unmounted."),(0,o.kt)("p",null,"With this approach, we will only be able to call an action when the screen focuses. This is great for fetching data with an API call when a screen becomes focused, or any other action that needs to happen once the screen comes into view."),(0,o.kt)("h3",{id:"example-1"},"Example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React, { Component } from 'react';\nimport { View } from 'react-native';\nimport { withNavigation } from 'react-navigation';\n\nclass TabScreen extends Component {\n  componentDidMount() {\n    const { navigation } = this.props;\n    this.focusListener = navigation.addListener('didFocus', () => {\n      // The screen is focused\n      // Call any action\n    });\n  }\n\n  componentWillUnmount() {\n    // Remove the event listener\n    this.focusListener.remove();\n  }\n\n  render() {\n    return <View />;\n  }\n}\n\nexport default withNavigation(TabScreen);\n")))}h.isMDXComponent=!0}}]);