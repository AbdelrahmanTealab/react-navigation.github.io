"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[77685],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(67294),i=n(86010),r={tabItem:"tabItem_Ymn6"};function o(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,o),hidden:n},t)}},74866:function(e,t,n){n.d(t,{Z:function(){return y}});var a=n(83117),i=n(67294),r=n(86010),o=n(12466),l=n(16550),s=n(91980),u=n(67392),c=n(50012);function p(e){return function(e){return i.Children.map(e,(function(e){if((0,i.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function d(e){var t=e.values,n=e.children;return(0,i.useMemo)((function(){var e=null!=t?t:p(n);return function(e){var t=(0,u.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function h(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId,r=(0,l.k6)(),o=function(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,s._X)(o),(0,i.useCallback)((function(e){if(o){var t=new URLSearchParams(r.location.search);t.set(o,e),r.replace(Object.assign({},r.location,{search:t.toString()}))}}),[o,r])]}function k(e){var t,n,a,r,o=e.defaultValue,l=e.queryString,s=void 0!==l&&l,u=e.groupId,p=d(e),k=(0,i.useState)((function(){return function(e){var t,n=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var i=null!=(t=a.find((function(e){return e.default})))?t:a[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:o,tabValues:p})})),v=k[0],g=k[1],f=h({queryString:s,groupId:u}),N=f[0],b=f[1],y=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:u}.groupId),n=(0,c.Nk)(t),a=n[0],r=n[1],[a,(0,i.useCallback)((function(e){t&&r.set(e)}),[t,r])]),w=y[0],C=y[1],E=function(){var e=null!=N?N:w;return m({value:e,tabValues:p})?e:null}();return(0,i.useLayoutEffect)((function(){E&&g(E)}),[E]),{selectedValue:v,selectValue:(0,i.useCallback)((function(e){if(!m({value:e,tabValues:p}))throw new Error("Can't select invalid tab value="+e);g(e),b(e),C(e)}),[b,C,p]),tabValues:p}}var v=n(72389),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){var t=e.className,n=e.block,l=e.selectedValue,s=e.selectValue,u=e.tabValues,c=[],p=(0,o.o5)().blockElementScrollPositionUntilNextRender,d=function(e){var t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==l&&(p(t),s(a))},m=function(e){var t,n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":var a,i=c.indexOf(e.currentTarget)+1;n=null!=(a=c[i])?a:c[0];break;case"ArrowLeft":var r,o=c.indexOf(e.currentTarget)-1;n=null!=(r=c[o])?r:c[c.length-1]}null==(t=n)||t.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},u.map((function(e){var t=e.value,n=e.label,o=e.attributes;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:function(e){return c.push(e)},onKeyDown:m,onClick:d},o,{className:(0,r.Z)("tabs__item",g.tabItem,null==o?void 0:o.className,{"tabs__item--active":l===t})}),null!=n?n:t)})))}function N(e){var t=e.lazy,n=e.children,a=e.selectedValue;if(n=Array.isArray(n)?n:[n],t){var r=n.find((function(e){return e.props.value===a}));return r?(0,i.cloneElement)(r,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},n.map((function(e,t){return(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==a})})))}function b(e){var t=k(e);return i.createElement("div",{className:(0,r.Z)("tabs-container",g.tabList)},i.createElement(f,(0,a.Z)({},e,t)),i.createElement(N,(0,a.Z)({},e,t)))}function y(e){var t=(0,v.Z)();return i.createElement(b,(0,a.Z)({key:String(t)},e))}},81637:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return p}});var a=n(83117),i=n(80102),r=(n(67294),n(3905)),o=(n(74866),n(85162),["components"]),l={id:"navigation-prop",title:"Navigation prop reference",sidebar_label:"Navigation prop"},s=void 0,u={unversionedId:"navigation-prop",id:"version-3.x/navigation-prop",title:"Navigation prop reference",description:"Each screen component in your app is provided with the navigation prop automatically. The prop contains various convenience functions that dispatch navigation actions on the route's router. It looks like this:",source:"@site/versioned_docs/version-3.x/navigation-prop.md",sourceDirName:".",slug:"/navigation-prop",permalink:"/docs/3.x/navigation-prop",draft:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-3.x/navigation-prop.md",tags:[],version:"3.x",frontMatter:{id:"navigation-prop",title:"Navigation prop reference",sidebar_label:"Navigation prop"},sidebar:"version-3.x-docs",previous:{title:"Call a function when focused screen changes",permalink:"/docs/3.x/function-after-focusing-screen"},next:{title:"NavigationContext",permalink:"/docs/3.x/navigation-context"}},c={},p=[{value:"Navigator-dependent functions",id:"navigator-dependent-functions",level:3},{value:"Common API reference",id:"common-api-reference",level:2},{value:"<code>navigate</code> - Link to other screens",id:"navigate---link-to-other-screens",level:3},{value:"<code>goBack</code> - Close the active screen and move back",id:"goback---close-the-active-screen-and-move-back",level:3},{value:"Going back from a specific screen with <code>goBack</code>",id:"going-back-from-a-specific-screen-with-goback",level:3},{value:"<code>addListener</code> - Subscribe to updates to navigation lifecycle",id:"addlistener---subscribe-to-updates-to-navigation-lifecycle",level:3},{value:"<code>isFocused</code> - Query the focused state of the screen",id:"isfocused---query-the-focused-state-of-the-screen",level:3},{value:"<code>state</code> - The screen&#39;s current state/route",id:"state---the-screens-current-stateroute",level:3},{value:"<code>setParams</code> - Make changes to route params",id:"setparams---make-changes-to-route-params",level:3},{value:"<code>getParam</code> - Get a specific param value with a fallback",id:"getparam---get-a-specific-param-value-with-a-fallback",level:3},{value:"Stack Actions",id:"stack-actions",level:2},{value:"Push",id:"push",level:3},{value:"Pop",id:"pop",level:3},{value:"PopToTop",id:"poptotop",level:3},{value:"Replace",id:"replace",level:3},{value:"Reset",id:"reset",level:3},{value:"Dismiss",id:"dismiss",level:3},{value:"Advanced API Reference",id:"advanced-api-reference",level:2},{value:"<code>dispatch</code> - Send an action to the router",id:"dispatch---send-an-action-to-the-router",level:3},{value:"<code>dangerouslyGetParent</code> - get parent navigator",id:"dangerouslygetparent---get-parent-navigator",level:3}],d={toc:p},m="wrapper";function h(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"screen")," component in your app is provided with the ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation")," prop automatically. The prop contains various convenience functions that dispatch navigation actions on the route's router. It looks like this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"this.props.navigation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"navigate")," - go to another screen, figures out the action it needs to take to do it"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"goBack")," - close active screen and move back in the stack"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"addListener")," - subscribe to updates to navigation lifecycle"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"isFocused")," - function that returns ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," if the screen is focused and ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," otherwise."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"state")," - current state/routes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"setParams")," - make changes to route's params"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getParam")," - get a specific param with fallback"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dispatch")," - send an action to router"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dangerouslyGetParent")," - function that returns the parent navigator, if any")))),(0,r.kt)("p",null,"It's important to highlight the ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation")," prop is ",(0,r.kt)("em",{parentName:"p"},"not")," passed in to ",(0,r.kt)("em",{parentName:"p"},"all")," components; only ",(0,r.kt)("inlineCode",{parentName:"p"},"screen")," components receive this prop automatically! React Navigation doesn't do anything magic here. For example, if you were to define a ",(0,r.kt)("inlineCode",{parentName:"p"},"MyBackButton")," component and render it as a child of a screen component, you would not be able to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation")," prop on it. If, however, you wish to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation")," prop in any of your components, you may use the ",(0,r.kt)("a",{parentName:"p",href:"/docs/3.x/with-navigation"},(0,r.kt)("inlineCode",{parentName:"a"},"withNavigation"))," HOC."),(0,r.kt)("h3",{id:"navigator-dependent-functions"},"Navigator-dependent functions"),(0,r.kt)("p",null,"There are several additional functions present on ",(0,r.kt)("inlineCode",{parentName:"p"},"this.props.navigation")," based on the kind of the current navigator."),(0,r.kt)("p",null,"If the navigator is a stack navigator, several alternatives to ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"goBack")," are provided and you can use whichever you prefer. The functions are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"this.props.navigation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"push")," - push a new route onto the stack"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pop")," - go back in the stack"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"popToTop")," - go to the top of the stack"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"replace")," - replace the current route with a new one"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"reset")," - wipe the navigator state and replace it with the result of several actions"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"dismiss")," - dismiss the current stack")))),(0,r.kt)("p",null,"If the navigator is a drawer navigator, the following are also available:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"this.props.navigation"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"openDrawer")," - open the drawer"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"closeDrawer")," - close the drawer"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toggleDrawer")," - toggle the state, ie. switch from closed to open and vice versa")))),(0,r.kt)("h2",{id:"common-api-reference"},"Common API reference"),(0,r.kt)("p",null,"The vast majority of your interactions with the ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation")," prop will involve ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"goBack"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"setParams")," / ",(0,r.kt)("inlineCode",{parentName:"p"},"getParam"),"."),(0,r.kt)("h3",{id:"navigate---link-to-other-screens"},(0,r.kt)("inlineCode",{parentName:"h3"},"navigate")," - Link to other screens"),(0,r.kt)("p",null,"Call this to link to another screen in your app. Takes the following arguments:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"navigation.navigate({ routeName, params, action, key })")),(0,r.kt)("p",null,"OR"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"navigation.navigate(routeName, params, action)")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"routeName")," - A destination routeName that has been registered somewhere in the app's router"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"params")," - Params to merge into the destination route"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"action")," - (advanced) The sub-action to run in the child router, if the screen is a navigator. See ",(0,r.kt)("a",{parentName:"li",href:"/docs/3.x/navigation-actions"},"Actions Doc")," for a full list of supported actions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"key")," - Optional identifier of what route to navigate to. Navigate ",(0,r.kt)("strong",{parentName:"li"},"back")," to this route, if it already exists")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class HomeScreen extends React.Component {\n  render() {\n    const { navigate } = this.props.navigation;\n\n    return (\n      <View>\n        <Text>This is the home screen of the app</Text>\n        <Button\n          onPress={() => navigate('Profile', { name: 'Brent' })}\n          title=\"Go to Brent's profile\"\n        />\n      </View>\n    );\n  }\n}\n")),(0,r.kt)("h3",{id:"goback---close-the-active-screen-and-move-back"},(0,r.kt)("inlineCode",{parentName:"h3"},"goBack")," - Close the active screen and move back"),(0,r.kt)("p",null,"Optionally provide a key, which specifies the route to go back from. By default, ",(0,r.kt)("inlineCode",{parentName:"p"},"goBack")," will close the route that it is called from. If the goal is to go back ",(0,r.kt)("em",{parentName:"p"},"anywhere"),", without specifying what is getting closed, call ",(0,r.kt)("inlineCode",{parentName:"p"},".goBack(null);")," Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," parameter is useful in the case of nested ",(0,r.kt)("inlineCode",{parentName:"p"},"StackNavigators")," to go back on a parent navigator when the child navigator already has only one item in the stack. Don't be concerned if this is confusing, this API needs some work."),(0,r.kt)("p",null,"Note -- a key is not the name of the route but the unique identifier you provided when navigating to the route. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/3.x/navigation-key"},"navigation key"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'class HomeScreen extends React.Component {\n  render() {\n    const { goBack } = this.props.navigation;\n    return (\n      <View>\n        <Button onPress={() => goBack()} title="Go back from this HomeScreen" />\n        <Button onPress={() => goBack(null)} title="Go back anywhere" />\n        <Button\n          onPress={() => goBack(\'key-123\')}\n          title="Go back from key-123"\n        />\n      </View>\n    );\n  }\n}\n')),(0,r.kt)("h3",{id:"going-back-from-a-specific-screen-with-goback"},"Going back from a specific screen with ",(0,r.kt)("inlineCode",{parentName:"h3"},"goBack")),(0,r.kt)("p",null,"Consider the following navigation stack history:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"navigation.navigate({routeName: SCREEN, key: SCREEN_KEY_A});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_B});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_C});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_D});\n")),(0,r.kt)("p",null,"Now you are on ",(0,r.kt)("em",{parentName:"p"},"screen D")," and want to go back to ",(0,r.kt)("em",{parentName:"p"},"screen A")," (popping D, C, and B).\nThen you need to supply a key to goBack ",(0,r.kt)("em",{parentName:"p"},"FROM"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"navigation.goBack(SCREEN_KEY_B) // will go to screen A FROM screen B\n")),(0,r.kt)("p",null,"Alternatively, as ",(0,r.kt)("em",{parentName:"p"},"screen A")," is the top of the stack, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"navigation.popToTop()"),"."),(0,r.kt)("h3",{id:"addlistener---subscribe-to-updates-to-navigation-lifecycle"},(0,r.kt)("inlineCode",{parentName:"h3"},"addListener")," - Subscribe to updates to navigation lifecycle"),(0,r.kt)("p",null,"React Navigation emits events to screen components that subscribe to them:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"willFocus")," - the screen will focus"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"didFocus")," - the screen focused (if there was a transition, the transition completed)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"willBlur")," - the screen will be unfocused"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"didBlur")," - the screen unfocused (if there was a transition, the transition completed)")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const didBlurSubscription = this.props.navigation.addListener(\n  'didBlur',\n  payload => {\n    console.debug('didBlur', payload);\n  }\n);\n\n// Remove the listener when you are done\ndidBlurSubscription.remove();\n")),(0,r.kt)("p",null,"The JSON payload:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n  action: { type: 'Navigation/COMPLETE_TRANSITION', key: 'StackRouterRoot' },\n  context: 'id-1518521010538-2:Navigation/COMPLETE_TRANSITION_Root',\n  lastState: undefined,\n  state: undefined,\n  type: 'didBlur',\n};\n")),(0,r.kt)("p",null,"You can also subscribe to navigation events declaratively with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/3.x/navigation-events"},(0,r.kt)("inlineCode",{parentName:"a"},"<NavigationEvents/>"))," component."),(0,r.kt)("h3",{id:"isfocused---query-the-focused-state-of-the-screen"},(0,r.kt)("inlineCode",{parentName:"h3"},"isFocused")," - Query the focused state of the screen"),(0,r.kt)("p",null,"Returns ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," if the screen is focused and ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"let isFocused = this.props.navigation.isFocused();\n")),(0,r.kt)("p",null,"You probably want to use ",(0,r.kt)("a",{parentName:"p",href:"/docs/3.x/with-navigation-focus"},"withNavigationFocus")," instead of using this directly, it will pass in an ",(0,r.kt)("inlineCode",{parentName:"p"},"isFocused")," boolean a prop to your component."),(0,r.kt)("h3",{id:"state---the-screens-current-stateroute"},(0,r.kt)("inlineCode",{parentName:"h3"},"state")," - The screen's current state/route"),(0,r.kt)("p",null,"A screen has access to its route via ",(0,r.kt)("inlineCode",{parentName:"p"},"this.props.navigation.state"),". Each will return an object with the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"{\n  // the name of the route config in the router\n  routeName: 'profile',\n  //a unique identifier used to sort routes\n  key: 'main0',\n  //an optional object of string options for this screen\n  params: { hello: 'world' }\n}\n")),(0,r.kt)("p",null,"This is most commonly used to access the ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," for the screen, passed in through ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"setParams"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class ProfileScreen extends React.Component {\n  render() {\n    return <Text>Name: {this.props.navigation.state.params.name}</Text>;\n  }\n}\n")),(0,r.kt)("h3",{id:"setparams---make-changes-to-route-params"},(0,r.kt)("inlineCode",{parentName:"h3"},"setParams")," - Make changes to route params"),(0,r.kt)("p",null,"Firing the ",(0,r.kt)("inlineCode",{parentName:"p"},"setParams")," action allows a screen to change the params in the route, which is useful for updating the header buttons and title. ",(0,r.kt)("inlineCode",{parentName:"p"},"setParams")," works like React's ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," - it merges the provided params object with the current params."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class ProfileScreen extends React.Component {\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.setParams({ name: 'Lucy' })}\n        title=\"Set title name to 'Lucy'\"\n      />\n    );\n  }\n}\n")),(0,r.kt)("h3",{id:"getparam---get-a-specific-param-value-with-a-fallback"},(0,r.kt)("inlineCode",{parentName:"h3"},"getParam")," - Get a specific param value with a fallback"),(0,r.kt)("p",null,"In the past, you may have encountered the frightful scenario of accessing a ",(0,r.kt)("inlineCode",{parentName:"p"},"param")," when ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," is undefined. Instead of accessing the param directly, you can call ",(0,r.kt)("inlineCode",{parentName:"p"},"getParam")," instead."),(0,r.kt)("p",null,"Before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { name } = this.props.navigation.state.params;\n")),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", this fails"),(0,r.kt)("p",null,"After:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const name = this.props.navigation.getParam('name', 'Peter');\n")),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"param")," are undefined, set the fallback to ",(0,r.kt)("inlineCode",{parentName:"p"},"Peter"),"."),(0,r.kt)("h2",{id:"stack-actions"},"Stack Actions"),(0,r.kt)("p",null,"The following actions will work within any stack navigator:"),(0,r.kt)("h3",{id:"push"},"Push"),(0,r.kt)("p",null,"Similar to navigate, push will move you forward to a new route in the stack. This differs from ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate")," in that ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate")," will pop back to earlier in the stack if a route of the given name is already present there. ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," will always add on top, so a route can be present multiple times."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.push(routeName, params, action)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"routeName")," - A destination routeName that has been registered somewhere in the app's router."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"params")," - Params to merge into the destination route."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"action")," - (advanced) The sub-action to run in the child router, if the screen is a navigator. See ",(0,r.kt)("a",{parentName:"li",href:"/docs/3.x/navigation-actions"},"Actions Doc")," for a full list of supported actions.")),(0,r.kt)("h3",{id:"pop"},"Pop"),(0,r.kt)("p",null,"Take you to the previous screen in the stack. If you provide a number, ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", it will specify how many screens to take you back within the stack."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.pop(n)\n")),(0,r.kt)("h3",{id:"poptotop"},"PopToTop"),(0,r.kt)("p",null,"Call this to jump back to the top route in the stack, dismissing all other screens."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.popToTop()\n")),(0,r.kt)("h3",{id:"replace"},"Replace"),(0,r.kt)("p",null,"Call this to replace the current screen with the given route, with params and sub-action."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.replace(routeName, params, action)\n")),(0,r.kt)("h3",{id:"reset"},"Reset"),(0,r.kt)("p",null,"Wipe the navigator state and replace it with the result of several actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.reset([NavigationActions.navigate({ routeName: 'Profile' })], 0)\n")),(0,r.kt)("h3",{id:"dismiss"},"Dismiss"),(0,r.kt)("p",null,"Call this if you're in a nested (child) stack and want to dismiss the entire stack, returning to the parent stack."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"navigation.dismiss()\n")),(0,r.kt)("h2",{id:"advanced-api-reference"},"Advanced API Reference"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"dispatch")," function is much less commonly used, but a good escape hatch if you can't do what you need with ",(0,r.kt)("inlineCode",{parentName:"p"},"navigate")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"goBack"),"."),(0,r.kt)("h3",{id:"dispatch---send-an-action-to-the-router"},(0,r.kt)("inlineCode",{parentName:"h3"},"dispatch")," - Send an action to the router"),(0,r.kt)("p",null,"Use dispatch to send any navigation action to the router. The other navigation functions use dispatch behind the scenes."),(0,r.kt)("p",null,"Note that if you want to dispatch react-navigation actions you should use the action creators provided in this library."),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"/docs/3.x/navigation-actions"},"Navigation Actions Docs")," for a full list of available actions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { NavigationActions } from 'react-navigation';\n\nconst navigateAction = NavigationActions.navigate({\n  routeName: 'Profile',\n  params: {},\n\n  // navigate can have a nested navigate action that will be run inside the child router\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute' }),\n});\nthis.props.navigation.dispatch(navigateAction);\n")),(0,r.kt)("h3",{id:"dangerouslygetparent---get-parent-navigator"},(0,r.kt)("inlineCode",{parentName:"h3"},"dangerouslyGetParent")," - get parent navigator"),(0,r.kt)("p",null,"If, for example, you have a screen component that can be presented within multiple navigators, you may use this to influence its behavior based on what navigator it is in."),(0,r.kt)("p",null,"Another good use case for this is to find the index of the active route in the parent's route list. So in the case of a stack if you are at index 0 then you may not want to render a back button, but if you're somewhere else in the list then you would render a back button."),(0,r.kt)("p",null,"Be sure to always check that the call returns a valid value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"class UserCreateScreen extends Component {\n  static navigationOptions = ({ navigation }) => {\n    const parent = navigation.dangerouslyGetParent();\n    const gesturesEnabled =\n      parent &&\n      parent.state &&\n      parent.state.routeName === 'StackWithEnabledGestures';\n\n    return {\n      title: 'New User',\n      gesturesEnabled\n    };\n  };\n}\n\n")))}h.isMDXComponent=!0}}]);