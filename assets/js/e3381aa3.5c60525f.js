"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[52450],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(t),h=i,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return t?a.createElement(m,r(r({ref:n},u),{},{components:t})):a.createElement(m,r({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=t[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},64301:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var a=t(87462),i=t(63366),o=(t(67294),t(3905)),r=["components"],s={id:"static-authentication",title:"Authentication flow with static API",sidebar_label:"Authentication flow"},l=void 0,c={unversionedId:"static-authentication",id:"version-7.x/static-authentication",isDocsHomePage:!1,title:"Authentication flow with static API",description:"Most apps require that a user authenticate in some way to have access to data associated with a user or other private content. Typically the flow will look like this:",source:"@site/versioned_docs/version-7.x/static-authentication.md",sourceDirName:".",slug:"/static-authentication",permalink:"/docs/7.x/static-authentication",editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-authentication.md",tags:[],version:"7.x",frontMatter:{id:"static-authentication",title:"Authentication flow with static API",sidebar_label:"Authentication flow"},sidebar:"version-7.x/docs",previous:{title:"Configuring TypeScript",permalink:"/docs/7.x/static-typescript"},next:{title:"Combining with dynamic API",permalink:"/docs/7.x/static-combine-with-dynamic"}},u=[{value:"What we need",id:"what-we-need",children:[],level:2},{value:"How it will work",id:"how-it-will-work",children:[],level:2},{value:"Don&#39;t manually navigate when using <code>if</code> for conditional screens",id:"dont-manually-navigate-when-using-if-for-conditional-screens",children:[],level:2},{value:"Define the hooks",id:"define-the-hooks",children:[],level:2},{value:"Define our screens",id:"define-our-screens",children:[],level:2},{value:"Implement the logic for restoring the token",id:"implement-the-logic-for-restoring-the-token",children:[],level:2},{value:"Fill in other components",id:"fill-in-other-components",children:[],level:2}],p={toc:u};function d(e){var n=e.components,t=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Most apps require that a user authenticate in some way to have access to data associated with a user or other private content. Typically the flow will look like this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The user opens the app."),(0,o.kt)("li",{parentName:"ul"},"The app loads some authentication state from encrypted persistent storage (for example, ",(0,o.kt)("a",{parentName:"li",href:"https://docs.expo.io/versions/latest/sdk/securestore/"},(0,o.kt)("inlineCode",{parentName:"a"},"SecureStore")),")."),(0,o.kt)("li",{parentName:"ul"},"When the state has loaded, the user is presented with either authentication screens or the main app, depending on whether valid authentication state was loaded."),(0,o.kt)("li",{parentName:"ul"},"When the user signs out, we clear the authentication state and send them back to authentication screens.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},'Note: We say "authentication screens" because usually there is more than one. You may have a main screen with a username and password field, another for "forgot password", and another set for sign up.')),(0,o.kt)("h2",{id:"what-we-need"},"What we need"),(0,o.kt)("p",null,"This is the behavior that we want from the authentication flow: when users sign in, we want to throw away the state of the authentication flow and unmount all of the screens related to authentication, and when we press the hardware back button we expect to not be able to go back to the authentication flow."),(0,o.kt)("h2",{id:"how-it-will-work"},"How it will work"),(0,o.kt)("p",null,"We can configure different screens to be available based on some condition. For example, if the user is signed in, we can define ",(0,o.kt)("inlineCode",{parentName:"p"},"Home"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Profile"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Settings")," etc. If the user is not signed in, we can define ",(0,o.kt)("inlineCode",{parentName:"p"},"SignIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"SignUp")," screens. To do this, we need a couple of things:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define two hooks: ",(0,o.kt)("inlineCode",{parentName:"li"},"useIsSignedIn")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"useIsSignedOut"),", which return a boolean value indicating whether the user is signed in or not."),(0,o.kt)("li",{parentName:"ol"},"Use the ",(0,o.kt)("inlineCode",{parentName:"li"},"useIsSignedIn")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"useIsSignedOut")," along with the ",(0,o.kt)("a",{parentName:"li",href:"/docs/7.x/static-api-reference#if"},(0,o.kt)("inlineCode",{parentName:"a"},"if"))," property to define the screens that are available based on the condition.")),(0,o.kt)("p",null,"This tells React Navigation to show specific screens based on the signed in status. When the signed in status changes, React Navigation will automatically show the appropriate screen."),(0,o.kt)("h2",{id:"dont-manually-navigate-when-using-if-for-conditional-screens"},"Don't manually navigate when using ",(0,o.kt)("inlineCode",{parentName:"h2"},"if")," for conditional screens"),(0,o.kt)("p",null,"It's important to note that when using such a setup, you ",(0,o.kt)("strong",{parentName:"p"},"don't manually navigate")," to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Home")," screen by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation.navigate('Home')")," or any other method. ",(0,o.kt)("strong",{parentName:"p"},"React Navigation will automatically navigate to the correct screen")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"isSignedIn")," changes - ",(0,o.kt)("inlineCode",{parentName:"p"},"Home")," screen when ",(0,o.kt)("inlineCode",{parentName:"p"},"isSignedIn")," becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),", and to ",(0,o.kt)("inlineCode",{parentName:"p"},"SignIn")," screen when ",(0,o.kt)("inlineCode",{parentName:"p"},"isSignedIn")," becomes ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". You'll get an error if you attempt to navigate manually."),(0,o.kt)("h2",{id:"define-the-hooks"},"Define the hooks"),(0,o.kt)("p",null,"To implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedOut")," hooks, we can start by creating a context to store the authentication state. Let's call it ",(0,o.kt)("inlineCode",{parentName:"p"},"SignInContext"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import * as React from 'react';\n\nconst SignInContext = React.createContext();\n")),(0,o.kt)("p",null,"Then we can implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedOut")," hooks as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"function useIsSignedIn() {\n  const isSignedIn = React.useContext(SignInContext);\n  return isSignedIn;\n}\n\nfunction useIsSignedOut() {\n  const isSignedIn = React.useContext(SignInContext);\n  return !isSignedIn;\n}\n")),(0,o.kt)("p",null,"We'll discuss how to expose the context value later."),(0,o.kt)("h2",{id:"define-our-screens"},"Define our screens"),(0,o.kt)("p",null,"For our case, let's say we have 3 screens:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SplashScreen")," - This will show a splash or loading screen when we're restoring the token."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"SignIn")," - This is the screen we show if the user isn't signed in already (we couldn't find a token)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Home")," - This is the screen we show if the user is already signed in.")),(0,o.kt)("p",null,"We'd have our navigation tree defined with these screens as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      if: useIsSignedIn,\n      screen: HomeScreen,\n    },\n    SignIn: {\n      if: useIsSignedOut,\n      screen: SignInScreen,\n      options: {\n        title: 'Sign in',\n      },\n    },\n  },\n});\n\nconst Navigation = createStaticNavigation(RootStack);\n")),(0,o.kt)("p",null,"Notice how we have only defined the ",(0,o.kt)("inlineCode",{parentName:"p"},"Home")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"SignIn")," screens here, and not the ",(0,o.kt)("inlineCode",{parentName:"p"},"SplashScreen"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"SplashScreen")," should be rendered before we render any navigators so that we don't render incorrect screens before we know whether the user is signed in or not."),(0,o.kt)("p",null,"When we use this in our component, it'd look something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"if (state.isLoading) {\n  // We haven't finished checking for the token yet\n  return <SplashScreen />;\n}\n\nconst isSignedIn = state.userToken != null;\n\nreturn (\n  <SignInContext.Provider value={isSignedIn}>\n    <Navigation />\n  </SignInContext.Provider>\n);\n")),(0,o.kt)("p",null,"In the above snippet, ",(0,o.kt)("inlineCode",{parentName:"p"},"isLoading")," means that we're still checking if we have a token. This can usually be done by checking if we have a token in ",(0,o.kt)("inlineCode",{parentName:"p"},"SecureStore")," and validating the token. After we get the token and if it's valid, we need to set the ",(0,o.kt)("inlineCode",{parentName:"p"},"userToken"),". We also have another state called ",(0,o.kt)("inlineCode",{parentName:"p"},"isSignout")," to have a different animation on sign out."),(0,o.kt)("p",null,"Next, we're exposing the sign in status via the ",(0,o.kt)("inlineCode",{parentName:"p"},"SignInContext")," so that it's available to the ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedIn")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useIsSignedOut")," hooks."),(0,o.kt)("p",null,"In the above example, we're have one screen for each case. But you could also define multiple screens. For example, you probably want to define password reset, signup, etc screens as well when the user isn't signed in. Similarly for the screens accessible after sign in, you probably have more than one screen. We can use ",(0,o.kt)("a",{parentName:"p",href:"/docs/7.x/static-api-reference#groups"},(0,o.kt)("inlineCode",{parentName:"a"},"groups"))," to define multiple screens:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const RootStack = createNativeStackNavigator({\n  screens: {\n    // Common screens\n  },\n  groups: {\n    SignedIn: {\n      if: useIsSignedIn,\n      screens: {\n        Home: HomeScreen,\n        Profile: ProfileScreen,\n      },\n    },\n    SignedOut: {\n      if: useIsSignedOut,\n      screens: {\n        SignIn: SignInScreen,\n        SignUp: SignUpScreen,\n        ResetPassword: ResetPasswordScreen,\n      },\n    },\n  },\n});\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"If you have both your login-related screens and rest of the screens in Stack navigators, we recommend to use a single Stack navigator and place the conditional inside instead of using 2 different navigators. This makes it possible to have a proper transition animation during login/logout.")),(0,o.kt)("h2",{id:"implement-the-logic-for-restoring-the-token"},"Implement the logic for restoring the token"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: The following is just an example of how you might implement the logic for authentication in your app. You don't need to follow it as is.")),(0,o.kt)("p",null,"From the previous snippet, we can see that we need 2 state variables:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isLoading")," - We set this to ",(0,o.kt)("inlineCode",{parentName:"li"},"true")," when we're trying to check if we already have a token saved in ",(0,o.kt)("inlineCode",{parentName:"li"},"SecureStore")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"userToken")," - The token for the user. If it's non-null, we assume the user is logged in, otherwise not.")),(0,o.kt)("p",null,"So we need to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Add some logic for restoring token, sign in and sign out"),(0,o.kt)("li",{parentName:"ul"},"Expose methods for sign in and sign out to other components")),(0,o.kt)("p",null,"We'll use ",(0,o.kt)("inlineCode",{parentName:"p"},"React.useReducer")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"React.useContext")," in this guide. But if you're using a state management library such as Redux or Mobx, you can use them for this functionality instead. In fact, in bigger apps, a global state management library is more suitable for storing authentication tokens. You can adapt the same approach to your state management library."),(0,o.kt)("p",null,"First we'll need to create a context for auth where we can expose necessary methods:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import * as React from 'react';\n\nconst AuthContext = React.createContext();\n")),(0,o.kt)("p",null,"In our component, we will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Store the token and loading state in ",(0,o.kt)("inlineCode",{parentName:"li"},"useReducer")),(0,o.kt)("li",{parentName:"ul"},"Persist it to ",(0,o.kt)("inlineCode",{parentName:"li"},"SecureStore")," and read it from there on app launch"),(0,o.kt)("li",{parentName:"ul"},"Expose the methods for sign in and sign out to child components using ",(0,o.kt)("inlineCode",{parentName:"li"},"AuthContext"))),(0,o.kt)("p",null,"So we'll have something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import * as React from 'react';\nimport * as SecureStore from 'expo-secure-store';\n\nexport default function App({ navigation }) {\n  const [state, dispatch] = React.useReducer(\n    (prevState, action) => {\n      switch (action.type) {\n        case 'RESTORE_TOKEN':\n          return {\n            ...prevState,\n            userToken: action.token,\n            isLoading: false,\n          };\n        case 'SIGN_IN':\n          return {\n            ...prevState,\n            userToken: action.token,\n          };\n        case 'SIGN_OUT':\n          return {\n            ...prevState,\n            userToken: null,\n          };\n      }\n    },\n    {\n      isLoading: true,\n      userToken: null,\n    }\n  );\n\n  React.useEffect(() => {\n    // Fetch the token from storage then navigate to our appropriate place\n    const bootstrapAsync = async () => {\n      let userToken;\n\n      try {\n        userToken = await SecureStore.getItemAsync('userToken');\n      } catch (e) {\n        // Restoring token failed\n      }\n\n      // After restoring token, we may need to validate it in production apps\n      // ...\n\n      // This will switch to the App screen or Auth screen and this loading\n      // screen will be unmounted and thrown away.\n      dispatch({ type: 'RESTORE_TOKEN', token: userToken });\n    };\n\n    bootstrapAsync();\n  }, []);\n\n  const authContext = React.useMemo(\n    () => ({\n      signIn: async (data) => {\n        // In a production app, we need to send some data (usually username, password) to server and get a token\n        // We will also need to handle errors if sign in failed\n        // After getting token, we need to persist the token using `SecureStore`\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n      signOut: () => dispatch({ type: 'SIGN_OUT' }),\n      signUp: async (data) => {\n        // In a production app, we need to send user data to server and get a token\n        // We will also need to handle errors if sign up failed\n        // After getting token, we need to persist the token using `SecureStore`\n        // In the example, we'll use a dummy token\n\n        dispatch({ type: 'SIGN_IN', token: 'dummy-auth-token' });\n      },\n    }),\n    []\n  );\n\n  if (state.isLoading) {\n    return <SplashScreen />;\n  }\n\n  return (\n    <AuthContext.Provider value={authContext}>\n      <SignInContext.Provider value={isSignedIn}>\n        <Navigation />\n      </SignInContext.Provider>\n    </AuthContext.Provider>\n  );\n}\n")),(0,o.kt)("h2",{id:"fill-in-other-components"},"Fill in other components"),(0,o.kt)("p",null,"We won't talk about how to implement the text inputs and buttons for the authentication screen, that is outside of the scope of navigation. We'll just fill in some placeholder content."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'function SignInScreen() {\n  const [username, setUsername] = React.useState(\'\');\n  const [password, setPassword] = React.useState(\'\');\n\n  const { signIn } = React.useContext(AuthContext);\n\n  return (\n    <View>\n      <TextInput\n        placeholder="Username"\n        value={username}\n        onChangeText={setUsername}\n      />\n      <TextInput\n        placeholder="Password"\n        value={password}\n        onChangeText={setPassword}\n        secureTextEntry\n      />\n      <Button title="Sign in" onPress={() => signIn({ username, password })} />\n    </View>\n  );\n}\n')),(0,o.kt)("p",null,"You can similarly fill in the other screens according to your requirements."))}d.isMDXComponent=!0}}]);