"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[53473],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=s(n),m=r,f=d["".concat(u,".").concat(m)]||d[m]||p[m]||i;return n?a.createElement(f,o(o({ref:t},l),{},{components:n})):a.createElement(f,o({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var u in t)hasOwnProperty.call(t,u)&&(c[u]=t[u]);c.originalType=e,c[d]="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(67294),r=n(86010),i={tabItem:"tabItem_Ymn6"};function o(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:n},t)}},74866:function(e,t,n){n.d(t,{Z:function(){return w}});var a=n(83117),r=n(67294),i=n(86010),o=n(12466),c=n(16550),u=n(91980),s=n(67392),l=n(50012);function d(e){return function(e){return r.Children.map(e,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function p(e){var t=e.values,n=e.children;return(0,r.useMemo)((function(){var e=null!=t?t:d(n);return function(e){var t=(0,s.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function f(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId,i=(0,c.k6)(),o=function(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,u._X)(o),(0,r.useCallback)((function(e){if(o){var t=new URLSearchParams(i.location.search);t.set(o,e),i.replace(Object.assign({},i.location,{search:t.toString()}))}}),[o,i])]}function v(e){var t,n,a,i,o=e.defaultValue,c=e.queryString,u=void 0!==c&&c,s=e.groupId,d=p(e),v=(0,r.useState)((function(){return function(e){var t,n=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var r=null!=(t=a.find((function(e){return e.default})))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:o,tabValues:d})})),h=v[0],g=v[1],b=f({queryString:u,groupId:s}),y=b[0],k=b[1],w=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:s}.groupId),n=(0,l.Nk)(t),a=n[0],i=n[1],[a,(0,r.useCallback)((function(e){t&&i.set(e)}),[t,i])]),N=w[0],S=w[1],P=function(){var e=null!=y?y:N;return m({value:e,tabValues:d})?e:null}();return(0,r.useLayoutEffect)((function(){P&&g(P)}),[P]),{selectedValue:h,selectValue:(0,r.useCallback)((function(e){if(!m({value:e,tabValues:d}))throw new Error("Can't select invalid tab value="+e);g(e),k(e),S(e)}),[k,S,d]),tabValues:d}}var h=n(72389),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){var t=e.className,n=e.block,c=e.selectedValue,u=e.selectValue,s=e.tabValues,l=[],d=(0,o.o5)().blockElementScrollPositionUntilNextRender,p=function(e){var t=e.currentTarget,n=l.indexOf(t),a=s[n].value;a!==c&&(d(t),u(a))},m=function(e){var t,n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":var a,r=l.indexOf(e.currentTarget)+1;n=null!=(a=l[r])?a:l[0];break;case"ArrowLeft":var i,o=l.indexOf(e.currentTarget)-1;n=null!=(i=l[o])?i:l[l.length-1]}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},s.map((function(e){var t=e.value,n=e.label,o=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:c===t?0:-1,"aria-selected":c===t,key:t,ref:function(e){return l.push(e)},onKeyDown:m,onClick:p},o,{className:(0,i.Z)("tabs__item",g.tabItem,null==o?void 0:o.className,{"tabs__item--active":c===t})}),null!=n?n:t)})))}function y(e){var t=e.lazy,n=e.children,a=e.selectedValue;if(n=Array.isArray(n)?n:[n],t){var i=n.find((function(e){return e.props.value===a}));return i?(0,r.cloneElement)(i,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})})))}function k(e){var t=v(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",g.tabList)},r.createElement(b,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function w(e){var t=(0,h.Z)();return r.createElement(k,(0,a.Z)({key:String(t)},e))}},7833:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return d}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),o=(n(74866),n(85162),["components"]),c={id:"static-combine-with-dynamic",title:"Combining static and dynamic APIs",sidebar_label:"Combining with dynamic API"},u=void 0,s={unversionedId:"static-combine-with-dynamic",id:"version-7.x/static-combine-with-dynamic",title:"Combining static and dynamic APIs",description:"While the static API has many advantages, it doesn't fit use cases where the navigation configuration needs to be dynamic. So React Navigation supports interop between the static and dynamic APIs.",source:"@site/versioned_docs/version-7.x/static-combine-with-dynamic.md",sourceDirName:".",slug:"/static-combine-with-dynamic",permalink:"/docs/7.x/static-combine-with-dynamic",draft:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-combine-with-dynamic.md",tags:[],version:"7.x",frontMatter:{id:"static-combine-with-dynamic",title:"Combining static and dynamic APIs",sidebar_label:"Combining with dynamic API"},sidebar:"version-7.x/docs",previous:{title:"Authentication flow",permalink:"/docs/7.x/static-authentication"},next:{title:"Stack",permalink:"/docs/7.x/stack-navigator"}},l={},d=[{value:"Static root navigator, dynamic nested navigator",id:"static-root-navigator-dynamic-nested-navigator",level:2},{value:"Dynamic root navigator, static nested navigator",id:"dynamic-root-navigator-static-nested-navigator",level:2}],p={toc:d},m="wrapper";function f(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"While the static API has many advantages, it doesn't fit use cases where the navigation configuration needs to be dynamic. So React Navigation supports interop between the static and dynamic APIs."),(0,i.kt)("p",null,"Keep in mind that the features provided by the static API such as automatic linking configuration and automatic TypeScript types need the whole configuration to be static. If part of the configuration is dynamic, you'll need to handle those parts manually."),(0,i.kt)("p",null,"There are 2 ways you may want to combine the static and dynamic APIs:"),(0,i.kt)("h2",{id:"static-root-navigator-dynamic-nested-navigator"},"Static root navigator, dynamic nested navigator"),(0,i.kt)("p",null,"This is useful if you want to keep your configuration static, but need to use a dynamic configuration for a specific navigator."),(0,i.kt)("p",null,"Let's consider the following example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You have a root stack navigator that contains a tab navigator in a screen."),(0,i.kt)("li",{parentName:"ul"},"The tab navigator is defined using the dynamic API.")),(0,i.kt)("p",null,"Our static configuration would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n      },\n    },\n  },\n});\n")),(0,i.kt)("p",null,"Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"FeedScreen")," is a component that renders a tab navigator and is defined using the dynamic API:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { createBottomTabNavigator } from \'@react-navigation/bottom-tabs\';\n\nconst Tab = createBottomTabNavigator();\n\nfunction FeedScreen() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Latest" component={LatestScreen} />\n      <Tab.Screen name="Popular" component={PopularScreen} />\n    </Tab.Navigator>\n  );\n}\n')),(0,i.kt)("p",null,"This code will work, but we're missing 2 things:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Linking configuration for the screens in the top tab navigator."),(0,i.kt)("li",{parentName:"ul"},"TypeScript types for the screens in the top tab navigator.")),(0,i.kt)("p",null,"Since the nested navigator is defined using the dynamic API, we need to handle these manually. For the linking configuration, we can define the screens in the ",(0,i.kt)("inlineCode",{parentName:"p"},"linking")," property of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Feed")," screen:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createNativeStackNavigator } from '@react-navigation/native-stack';\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: {\n      screen: HomeScreen,\n    },\n    Feed: {\n      screen: FeedScreen,\n      linking: {\n        path: 'feed',\n        screens: {\n          Latest: 'latest',\n          Popular: 'popular',\n        },\n      },\n    },\n  },\n});\n")),(0,i.kt)("p",null,"Here the ",(0,i.kt)("inlineCode",{parentName:"p"},"screens")," property is the same as how you'd define it with ",(0,i.kt)("inlineCode",{parentName:"p"},"linking")," config with the dynamic API. It can contain configuration for any nested navigators as well. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/7.x/configuring-links"},"configuring links")," for more details on the API."),(0,i.kt)("p",null,"For the TypeScript types, we can define the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"FeedScreen")," component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import {\n  StaticScreenProps,\n  NavigatorScreenParams,\n} from '@react-navigation/native';\n\ntype FeedParamList = {\n  Latest: undefined;\n  Popular: undefined;\n};\n\ntype Props = StaticScreenProps<NavigatorScreenParams<FeedParamList>>;\n\nfunction FeedScreen(_: Props) {\n  // ...\n}\n")),(0,i.kt)("p",null,"In the above snippet:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"We first define the param list type for screens in the navigator that defines params for each screen"),(0,i.kt)("li",{parentName:"ol"},"Then we use the ",(0,i.kt)("inlineCode",{parentName:"li"},"NavigatorScreenParams")," type to get the type of route's ",(0,i.kt)("inlineCode",{parentName:"li"},"params")," which will include types for the nested screens"),(0,i.kt)("li",{parentName:"ol"},"Finally, we use the type of ",(0,i.kt)("inlineCode",{parentName:"li"},"params")," with ",(0,i.kt)("inlineCode",{parentName:"li"},"StaticScreenProps")," to define the type of the screen component")),(0,i.kt)("p",null,"This is based on how we'd define the type for a screen with a nested navigator with the dynamic API. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/7.x/typescript#type-checking-screens-and-params-in-nested-navigator"},"Type checking screens and params in nested navigator"),"."),(0,i.kt)("h2",{id:"dynamic-root-navigator-static-nested-navigator"},"Dynamic root navigator, static nested navigator"),(0,i.kt)("p",null,"This is useful if you already have a dynamic configuration, but want to migrate to the static API. This way you can migrate one navigator at a time."),(0,i.kt)("p",null,"TODO"))}f.isMDXComponent=!0}}]);