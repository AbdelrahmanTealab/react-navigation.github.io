"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[24910],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return d}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},p="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=s(n),m=r,d=p["".concat(u,".").concat(m)]||p[m]||f[m]||i;return n?a.createElement(d,o(o({ref:t},l),{},{components:n})):a.createElement(d,o({ref:t},l))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var u in t)hasOwnProperty.call(t,u)&&(c[u]=t[u]);c.originalType=e,c[p]="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return o}});var a=n(67294),r=n(86010),i={tabItem:"tabItem_Ymn6"};function o(e){var t=e.children,n=e.hidden,o=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i.tabItem,o),hidden:n},t)}},74866:function(e,t,n){n.d(t,{Z:function(){return N}});var a=n(83117),r=n(67294),i=n(86010),o=n(12466),c=n(16550),u=n(91980),s=n(67392),l=n(50012);function p(e){return function(e){return r.Children.map(e,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function f(e){var t=e.values,n=e.children;return(0,r.useMemo)((function(){var e=null!=t?t:p(n);return function(e){var t=(0,s.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function d(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId,i=(0,c.k6)(),o=function(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,u._X)(o),(0,r.useCallback)((function(e){if(o){var t=new URLSearchParams(i.location.search);t.set(o,e),i.replace(Object.assign({},i.location,{search:t.toString()}))}}),[o,i])]}function v(e){var t,n,a,i,o=e.defaultValue,c=e.queryString,u=void 0!==c&&c,s=e.groupId,p=f(e),v=(0,r.useState)((function(){return function(e){var t,n=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var r=null!=(t=a.find((function(e){return e.default})))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:o,tabValues:p})})),g=v[0],b=v[1],h=d({queryString:u,groupId:s}),y=h[0],k=h[1],N=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:s}.groupId),n=(0,l.Nk)(t),a=n[0],i=n[1],[a,(0,r.useCallback)((function(e){t&&i.set(e)}),[t,i])]),T=N[0],P=N[1],w=function(){var e=null!=y?y:T;return m({value:e,tabValues:p})?e:null}();return(0,r.useLayoutEffect)((function(){w&&b(w)}),[w]),{selectedValue:g,selectValue:(0,r.useCallback)((function(e){if(!m({value:e,tabValues:p}))throw new Error("Can't select invalid tab value="+e);b(e),k(e),P(e)}),[k,P,p]),tabValues:p}}var g=n(72389),b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function h(e){var t=e.className,n=e.block,c=e.selectedValue,u=e.selectValue,s=e.tabValues,l=[],p=(0,o.o5)().blockElementScrollPositionUntilNextRender,f=function(e){var t=e.currentTarget,n=l.indexOf(t),a=s[n].value;a!==c&&(p(t),u(a))},m=function(e){var t,n=null;switch(e.key){case"Enter":f(e);break;case"ArrowRight":var a,r=l.indexOf(e.currentTarget)+1;n=null!=(a=l[r])?a:l[0];break;case"ArrowLeft":var i,o=l.indexOf(e.currentTarget)-1;n=null!=(i=l[o])?i:l[l.length-1]}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":n},t)},s.map((function(e){var t=e.value,n=e.label,o=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:c===t?0:-1,"aria-selected":c===t,key:t,ref:function(e){return l.push(e)},onKeyDown:m,onClick:f},o,{className:(0,i.Z)("tabs__item",b.tabItem,null==o?void 0:o.className,{"tabs__item--active":c===t})}),null!=n?n:t)})))}function y(e){var t=e.lazy,n=e.children,a=e.selectedValue;if(n=Array.isArray(n)?n:[n],t){var i=n.find((function(e){return e.props.value===a}));return i?(0,r.cloneElement)(i,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})})))}function k(e){var t=v(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",b.tabList)},r.createElement(h,(0,a.Z)({},e,t)),r.createElement(y,(0,a.Z)({},e,t)))}function N(e){var t=(0,g.Z)();return r.createElement(k,(0,a.Z)({key:String(t)},e))}},60839:function(e,t,n){n.r(t),n.d(t,{assets:function(){return l},contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return c},metadata:function(){return s},toc:function(){return p}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),o=(n(74866),n(85162),["components"]),c={id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},u=void 0,s={unversionedId:"static-typescript",id:"version-7.x/static-typescript",title:"Configuring TypeScript with static API",description:"There are 2 steps to configure TypeScript with the static API:",source:"@site/versioned_docs/version-7.x/static-typescript.md",sourceDirName:".",slug:"/static-typescript",permalink:"/docs/7.x/static-typescript",draft:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-typescript.md",tags:[],version:"7.x",frontMatter:{id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},sidebar:"version-7.x/docs",previous:{title:"API Reference",permalink:"/docs/7.x/static-api-reference"},next:{title:"Authentication flow",permalink:"/docs/7.x/static-authentication"}},l={},p=[{value:"Navigator specific types",id:"navigator-specific-types",level:2},{value:"Nesting navigator using dynamic API",id:"nesting-navigator-using-dynamic-api",level:2}],f={toc:p},m="wrapper";function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)(m,(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are 2 steps to configure TypeScript with the static API:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Each screen component needs to specify the type of the ",(0,i.kt)("inlineCode",{parentName:"li"},"route.params")," prop that it accepts. The ",(0,i.kt)("inlineCode",{parentName:"li"},"StaticScreenProps")," type makes it simpler:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { StaticScreenProps } from '@react-navigation/native';\n\ntype Props = StaticScreenProps<{\n  username: string;\n}>;\n\nfunction ProfileScreen({ route }: Props) {\n  // ...\n}\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Generate the ",(0,i.kt)("inlineCode",{parentName:"li"},"ParamList")," type for the root navigator and specify it as the default type for the ",(0,i.kt)("inlineCode",{parentName:"li"},"RootParamList")," type:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { StaticParamList } from '@react-navigation/native';\n\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: FeedScreen,\n    Profile: ProfileScreen,\n  },\n});\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n\ntype RootStackParamList = StaticParamList<typeof RootStack>;\n\ndeclare global {\n  namespace ReactNavigation {\n    interface RootParamList extends RootStackParamList {}\n  }\n}\n")),(0,i.kt)("p",null,"This is needed to type-check the ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," hook."),(0,i.kt)("h2",{id:"navigator-specific-types"},"Navigator specific types"),(0,i.kt)("p",null,"Generally we recommend using the default types for the ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," prop to access the navigation object in a navigator agnostic manner. However, if you need to use navigator specific APIs, you need to manually annotate ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type BottomTabParamList = StaticParamList<typeof BottomTabNavigator>;\ntype ProfileScreenNavigationProp = BottomTabNavigationProp<\n  BottomTabParamList,\n  'Profile'\n>;\n\n// ...\n\nconst navigation = useNavigation<ProfileScreenNavigationProp>();\n")),(0,i.kt)("p",null,"This follows the same principle as the types described in ",(0,i.kt)("a",{parentName:"p",href:"/docs/7.x/typescript"},"Type checking with TypeScript"),"."),(0,i.kt)("p",null,"Note that annotating ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," this way not type-safe since we can't guarantee that the type you provided matches the type of the navigator."),(0,i.kt)("h2",{id:"nesting-navigator-using-dynamic-api"},"Nesting navigator using dynamic API"),(0,i.kt)("p",null,"Consider the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const Tab = createBottomTabNavigator();\n\nfunction HomeTabs() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\nconst RootStack = createStackNavigator({\n  Home: HomeTabs,\n});\n')),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeTabs")," component is defined using the dynamic API. This means that when we create the param list for the root navigator with ",(0,i.kt)("inlineCode",{parentName:"p"},"StaticParamList<typeof RootStack>"),", it won't know about the screens defined in the nested navigator. To fix this, we'd need to specify the param list for the nested navigator explicitly."),(0,i.kt)("p",null,"This can be done by using the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"route")," prop that the screen component receives:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'type HomeTabsParamList = {\n  Feed: undefined;\n  Profile: undefined;\n};\n\ntype HomeTabsProps = StaticScreenProps<\n  NavigatorScreenParams<HomeTabsParamList>\n>;\n\nfunction HomeTabs(_: HomeTabsProps) {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n')),(0,i.kt)("p",null,"Now, when using ",(0,i.kt)("inlineCode",{parentName:"p"},"StaticParamList<typeof RootStack>"),", it will include the screens defined in the nested navigator."))}d.isMDXComponent=!0}}]);