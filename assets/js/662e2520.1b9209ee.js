"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[5954],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(k,r(r({ref:t},c),{},{components:n})):a.createElement(k,r({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},46856:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return d}});var a=n(87462),i=n(63366),o=(n(67294),n(3905)),r=["components"],l={id:"navigation-prop",title:"Navigation prop reference",sidebar_label:"Navigation prop"},s=void 0,p={unversionedId:"navigation-prop",id:"version-1.x/navigation-prop",isDocsHomePage:!1,title:"Navigation prop reference",description:"Each screen component in your app is provided with the navigation prop automatically. It looks like this:",source:"@site/versioned_docs/version-1.x/navigation-prop.md",sourceDirName:".",slug:"/navigation-prop",permalink:"/docs/1.x/navigation-prop",editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-1.x/navigation-prop.md",tags:[],version:"1.x",frontMatter:{id:"navigation-prop",title:"Navigation prop reference",sidebar_label:"Navigation prop"},sidebar:"api",previous:{title:"Overview",permalink:"/docs/1.x/api-reference"},next:{title:"NavigationActions",permalink:"/docs/1.x/navigation-actions"}},c=[{value:"Common API reference",id:"common-api-reference",children:[{value:"<code>navigate</code> - Link to other screens",id:"navigate---link-to-other-screens",children:[],level:3},{value:"<code>goBack</code> - Close the active screen and move back",id:"goback---close-the-active-screen-and-move-back",children:[],level:3},{value:"Going back from a specific screen with <code>goBack</code>",id:"going-back-from-a-specific-screen-with-goback",children:[],level:3},{value:"<code>addListener</code> - Subscribe to updates to navigation lifecycle",id:"addlistener---subscribe-to-updates-to-navigation-lifecycle",children:[],level:3},{value:"<code>isFocused</code> - Query the focused state of the screen",id:"isfocused---query-the-focused-state-of-the-screen",children:[],level:3},{value:"<code>state</code> - The screen&#39;s current state/route",id:"state---the-screens-current-stateroute",children:[],level:3},{value:"<code>setParams</code> - Make changes to route params",id:"setparams---make-changes-to-route-params",children:[],level:3},{value:"<code>getParam</code> - Get a specific param value with a fallback",id:"getparam---get-a-specific-param-value-with-a-fallback",children:[],level:3}],level:2},{value:"Stack Actions",id:"stack-actions",children:[{value:"Push",id:"push",children:[],level:3},{value:"Pop",id:"pop",children:[],level:3},{value:"PopToTop",id:"poptotop",children:[],level:3},{value:"Replace",id:"replace",children:[],level:3}],level:2},{value:"Advanced API Reference",id:"advanced-api-reference",children:[{value:"<code>dispatch</code> - Send an action to the router",id:"dispatch---send-an-action-to-the-router",children:[],level:3}],level:2}],u={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Each ",(0,o.kt)("inlineCode",{parentName:"p"},"screen")," component in your app is provided with the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation")," prop automatically. It looks like this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"this.props.navigation"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"navigate")," - go to another screen, figures out the action it needs to take to do it"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"goBack")," - close active screen and move back in the stack"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"addListener")," - subscribe to updates to navigation lifecycle"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"isFocused")," - function that returns ",(0,o.kt)("inlineCode",{parentName:"li"},"true")," if the screen is focused and ",(0,o.kt)("inlineCode",{parentName:"li"},"false")," otherwise."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"state")," - current state/routes"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"setParams")," - make changes to route's params"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getParam")," - get a specific param with fallback"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"dispatch")," - send an action to router")))),(0,o.kt)("p",null,"It's important to highlight the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation")," prop is ",(0,o.kt)("em",{parentName:"p"},"not")," passed in to ",(0,o.kt)("em",{parentName:"p"},"all")," components; only ",(0,o.kt)("inlineCode",{parentName:"p"},"screen")," components receive this prop automatically! React Navigation doesn't do anything magic here. For example, if you were to define a ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBackButton")," component and render it as a child of a screen component, you would not be able to access the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation")," prop on it."),(0,o.kt)("p",null,"There are several additional functions on ",(0,o.kt)("inlineCode",{parentName:"p"},"this.props.navigation")," that only if the current navigator is a ",(0,o.kt)("inlineCode",{parentName:"p"},"StackNavigator"),". These functions are alternatives to ",(0,o.kt)("inlineCode",{parentName:"p"},"navigate")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"goBack")," and you can use whichever you prefer. The functions are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"this.props.navigation"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"push")," - navigate forward to new route in stack"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"pop")," - go back in the stack"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"popToTop")," - go to the top of the stack"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"replace")," - replace the current route with a new one")))),(0,o.kt)("h2",{id:"common-api-reference"},"Common API reference"),(0,o.kt)("p",null,"The vast majority of your interactions with the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigation")," prop will involve ",(0,o.kt)("inlineCode",{parentName:"p"},"navigate"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"goBack"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"state"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"setParams"),"."),(0,o.kt)("h3",{id:"navigate---link-to-other-screens"},(0,o.kt)("inlineCode",{parentName:"h3"},"navigate")," - Link to other screens"),(0,o.kt)("p",null,"Call this to link to another screen in your app. Takes the following arguments:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"navigation.navigate({routeName, params, action, key})"),"\nOR\n",(0,o.kt)("inlineCode",{parentName:"p"},"navigation.navigate(routeName, params, action)")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"routeName")," - A destination routeName that has been registered somewhere in the app's router"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"params")," - Params to merge into the destination route"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"action")," - (advanced) The sub-action to run in the child router, if the screen is a navigator. See ",(0,o.kt)("a",{parentName:"li",href:"navigation-actions"},"Actions Doc")," for a full list of supported actions."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"key")," - Optional identifier of what route to navigate to. Navigate ",(0,o.kt)("strong",{parentName:"li"},"back")," to this route, if it already exists")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class HomeScreen extends React.Component {\n  render() {\n    const { navigate } = this.props.navigation;\n\n    return (\n      <View>\n        <Text>This is the home screen of the app</Text>\n        <Button\n          onPress={() => navigate('Profile', { name: 'Brent' })}\n          title=\"Go to Brent's profile\"\n        />\n      </View>\n    );\n  }\n}\n")),(0,o.kt)("h3",{id:"goback---close-the-active-screen-and-move-back"},(0,o.kt)("inlineCode",{parentName:"h3"},"goBack")," - Close the active screen and move back"),(0,o.kt)("p",null,"Optionally provide a key, which specifies the route to go back from. By default, ",(0,o.kt)("inlineCode",{parentName:"p"},"goBack")," will close the route that it is called from. If the goal is to go back ",(0,o.kt)("em",{parentName:"p"},"anywhere"),", without specifying what is getting closed, call ",(0,o.kt)("inlineCode",{parentName:"p"},".goBack(null);")," Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," parameter is useful in the case of nested ",(0,o.kt)("inlineCode",{parentName:"p"},"StackNavigators")," to go back on a parent navigator when the child navigator already has only one item in the stack. Don't be concerned if this is confusing, this API needs some work."),(0,o.kt)("p",null,"Note -- a key is not the name of the route but the unique identifier you provided when navigating to the route."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'class HomeScreen extends React.Component {\n  render() {\n    const { goBack } = this.props.navigation;\n    return (\n      <View>\n        <Button onPress={() => goBack()} title="Go back from this HomeScreen" />\n        <Button onPress={() => goBack(null)} title="Go back anywhere" />\n        <Button\n          onPress={() => goBack(\'key-123\')}\n          title="Go back from key-123"\n        />\n      </View>\n    );\n  }\n}\n')),(0,o.kt)("h3",{id:"going-back-from-a-specific-screen-with-goback"},"Going back from a specific screen with ",(0,o.kt)("inlineCode",{parentName:"h3"},"goBack")),(0,o.kt)("p",null,"Consider the following navigation stack history:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"navigation.navigate({routeName: SCREEN, key: SCREEN_KEY_A});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_B});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_C});\nnavigation.navigate({routeName: SCREEN, key: SCREEN_KEY_D});\n")),(0,o.kt)("p",null,"Now you are on ",(0,o.kt)("em",{parentName:"p"},"screen D")," and want to go back to ",(0,o.kt)("em",{parentName:"p"},"screen A")," (popping D, C, and B).\nThen you need to supply a key to goBack ",(0,o.kt)("em",{parentName:"p"},"FROM"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"navigation.goBack(SCREEN_KEY_B) // will go to screen A FROM screen B\n")),(0,o.kt)("h3",{id:"addlistener---subscribe-to-updates-to-navigation-lifecycle"},(0,o.kt)("inlineCode",{parentName:"h3"},"addListener")," - Subscribe to updates to navigation lifecycle"),(0,o.kt)("p",null,"React Navigation emits events to screen components that subscribe to them:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"willBlur")," - the screen will be unfocused"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"willFocus")," - the screen will focus"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"didFocus")," - the screen focused (if there was a transition, the transition completed)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"didBlur")," - the screen unfocused (if there was a transition, the transition completed)")),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const didBlurSubscription = this.props.navigation.addListener(\n  'didBlur',\n  payload => {\n    console.debug('didBlur', payload);\n  }\n);\n\n// Remove the listener when you are done\ndidBlurSubscription.remove();\n")),(0,o.kt)("p",null,"The JSON payload:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"{\n  action: { type: 'Navigation/COMPLETE_TRANSITION', key: 'StackRouterRoot' },\n  context: 'id-1518521010538-2:Navigation/COMPLETE_TRANSITION_Root',\n  lastState: undefined,\n  state: undefined,\n  type: 'didBlur',\n};\n")),(0,o.kt)("h3",{id:"isfocused---query-the-focused-state-of-the-screen"},(0,o.kt)("inlineCode",{parentName:"h3"},"isFocused")," - Query the focused state of the screen"),(0,o.kt)("p",null,"Returns ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if the screen is focused and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"let isFocused = this.props.navigation.isFocused();\n")),(0,o.kt)("p",null,"You probably want to use ",(0,o.kt)("a",{parentName:"p",href:"/docs/1.x/with-navigation-focus"},"withNavigationFocus")," instead of using this directly, it will pass in an ",(0,o.kt)("inlineCode",{parentName:"p"},"isFocused")," boolean a prop to your component."),(0,o.kt)("h3",{id:"state---the-screens-current-stateroute"},(0,o.kt)("inlineCode",{parentName:"h3"},"state")," - The screen's current state/route"),(0,o.kt)("p",null,"A screen has access to its route via ",(0,o.kt)("inlineCode",{parentName:"p"},"this.props.navigation.state"),". Each will return an object with the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"{\n  // the name of the route config in the router\n  routeName: 'profile',\n  //a unique identifier used to sort routes\n  key: 'main0',\n  //an optional object of string options for this screen\n  params: { hello: 'world' }\n}\n")),(0,o.kt)("p",null,"This is most commonly used to access the ",(0,o.kt)("inlineCode",{parentName:"p"},"params")," for the screen, passed in through ",(0,o.kt)("inlineCode",{parentName:"p"},"navigate")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"setParams"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class ProfileScreen extends React.Component {\n  render() {\n    return <Text>Name: {this.props.navigation.state.params.name}</Text>;\n  }\n}\n")),(0,o.kt)("h3",{id:"setparams---make-changes-to-route-params"},(0,o.kt)("inlineCode",{parentName:"h3"},"setParams")," - Make changes to route params"),(0,o.kt)("p",null,"Firing the ",(0,o.kt)("inlineCode",{parentName:"p"},"setParams")," action allows a screen to change the params in the route, which is useful for updating the header buttons and title."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"class ProfileScreen extends React.Component {\n  render() {\n    return (\n      <Button\n        onPress={() => this.props.navigation.setParams({ name: 'Lucy' })}\n        title=\"Set title name to 'Lucy'\"\n      />\n    );\n  }\n}\n")),(0,o.kt)("h3",{id:"getparam---get-a-specific-param-value-with-a-fallback"},(0,o.kt)("inlineCode",{parentName:"h3"},"getParam")," - Get a specific param value with a fallback"),(0,o.kt)("p",null,"In the past, you may have encountered the frightful scenario of accessing a ",(0,o.kt)("inlineCode",{parentName:"p"},"param")," when ",(0,o.kt)("inlineCode",{parentName:"p"},"params")," is undefined. Instead of accessing the param directly, you can call ",(0,o.kt)("inlineCode",{parentName:"p"},"getParam")," instead."),(0,o.kt)("p",null,"Before:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const { name } = this.props.navigation.state.params;\n")),(0,o.kt)("p",null,"if ",(0,o.kt)("inlineCode",{parentName:"p"},"params")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),", this fails"),(0,o.kt)("p",null,"After:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const name = this.props.navigation.getParam('name', 'Peter');\n")),(0,o.kt)("p",null,"if ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"param")," are undefined, set the fallback to ",(0,o.kt)("inlineCode",{parentName:"p"},"Peter"),"."),(0,o.kt)("h2",{id:"stack-actions"},"Stack Actions"),(0,o.kt)("p",null,"The following actions will work within any StackNavigator:"),(0,o.kt)("h3",{id:"push"},"Push"),(0,o.kt)("p",null,"Similar to navigate, push will move you forward to a new route in the stack."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"navigation.push(routeName, params, action)")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"routeName")," - A destination routeName that has been registered somewhere in the app's router"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"params")," - Params to merge into the destination route"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"action")," - (advanced) The sub-action to run in the child router, if the screen is a navigator. See ",(0,o.kt)("a",{parentName:"li",href:"navigation-actions"},"Actions Doc")," for a full list of supported actions.")),(0,o.kt)("h3",{id:"pop"},"Pop"),(0,o.kt)("p",null,'Take you to the previous screen in the stack. If you provide a number, "n", it will specify how many screens to take you back within the stack.'),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"navigation.pop(n)")),(0,o.kt)("h3",{id:"poptotop"},"PopToTop"),(0,o.kt)("p",null,"Call this to jump back to the top route in the stack, dismissing all other screens."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"navigation.popToTop()")),(0,o.kt)("h3",{id:"replace"},"Replace"),(0,o.kt)("p",null,"Call this to replace the current screen with the given route, with params and sub-action."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"navigation.replace(routeName, params, action)")),(0,o.kt)("h2",{id:"advanced-api-reference"},"Advanced API Reference"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"dispatch")," function is much less commonly used, but a good escape hatch if you can't do what you need with ",(0,o.kt)("inlineCode",{parentName:"p"},"navigate")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"goBack"),"."),(0,o.kt)("h3",{id:"dispatch---send-an-action-to-the-router"},(0,o.kt)("inlineCode",{parentName:"h3"},"dispatch")," - Send an action to the router"),(0,o.kt)("p",null,"Use dispatch to send any navigation action to the router. The other navigation functions use dispatch behind the scenes."),(0,o.kt)("p",null,"Note that if you want to dispatch react-navigation actions you should use the action creators provided in this library."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"navigation-actions"},"Navigation Actions Docs")," for a full list of available actions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { NavigationActions } from 'react-navigation';\n\nconst navigateAction = NavigationActions.navigate({\n  routeName: 'Profile',\n  params: {},\n\n  // navigate can have a nested navigate action that will be run inside the child router\n  action: NavigationActions.navigate({ routeName: 'SubProfileRoute' }),\n});\nthis.props.navigation.dispatch(navigateAction);\n")))}d.isMDXComponent=!0}}]);