"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[5514],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),d=l(n),m=r,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u[d]="string"==typeof e?e:r,i[1]=u;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return i}});var a=n(67294),r=n(86010),o={tabItem:"tabItem_Ymn6"};function i(e){var t=e.children,n=e.hidden,i=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,i),hidden:n},t)}},74866:function(e,t,n){n.d(t,{Z:function(){return N}});var a=n(83117),r=n(67294),o=n(86010),i=n(12466),u=n(16550),s=n(91980),l=n(67392),c=n(50012);function d(e){return function(e){return r.Children.map(e,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')}))}(e).map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes,default:t.default}}))}function p(e){var t=e.values,n=e.children;return(0,r.useMemo)((function(){var e=null!=t?t:d(n);return function(e){var t=(0,l.l)(e,(function(e,t){return e.value===t.value}));if(t.length>0)throw new Error('Docusaurus error: Duplicate values "'+t.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[t,n])}function m(e){var t=e.value;return e.tabValues.some((function(e){return e.value===t}))}function f(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId,o=(0,u.k6)(),i=function(e){var t=e.queryString,n=void 0!==t&&t,a=e.groupId;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=a?a:null}({queryString:n,groupId:a});return[(0,s._X)(i),(0,r.useCallback)((function(e){if(i){var t=new URLSearchParams(o.location.search);t.set(i,e),o.replace(Object.assign({},o.location,{search:t.toString()}))}}),[i,o])]}function h(e){var t,n,a,o,i=e.defaultValue,u=e.queryString,s=void 0!==u&&u,l=e.groupId,d=p(e),h=(0,r.useState)((function(){return function(e){var t,n=e.defaultValue,a=e.tabValues;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!m({value:n,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+n+'" but none of its children has the corresponding value. Available values are: '+a.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return n}var r=null!=(t=a.find((function(e){return e.default})))?t:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:i,tabValues:d})})),v=h[0],g=h[1],b=f({queryString:s,groupId:l}),k=b[0],y=b[1],N=(t=function(e){return e?"docusaurus.tab."+e:null}({groupId:l}.groupId),n=(0,c.Nk)(t),a=n[0],o=n[1],[a,(0,r.useCallback)((function(e){t&&o.set(e)}),[t,o])]),w=N[0],C=N[1],x=function(){var e=null!=k?k:w;return m({value:e,tabValues:d})?e:null}();return(0,r.useLayoutEffect)((function(){x&&g(x)}),[x]),{selectedValue:v,selectValue:(0,r.useCallback)((function(e){if(!m({value:e,tabValues:d}))throw new Error("Can't select invalid tab value="+e);g(e),y(e),C(e)}),[y,C,d]),tabValues:d}}var v=n(72389),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){var t=e.className,n=e.block,u=e.selectedValue,s=e.selectValue,l=e.tabValues,c=[],d=(0,i.o5)().blockElementScrollPositionUntilNextRender,p=function(e){var t=e.currentTarget,n=c.indexOf(t),a=l[n].value;a!==u&&(d(t),s(a))},m=function(e){var t,n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":var a,r=c.indexOf(e.currentTarget)+1;n=null!=(a=c[r])?a:c[0];break;case"ArrowLeft":var o,i=c.indexOf(e.currentTarget)-1;n=null!=(o=c[i])?o:c[c.length-1]}null==(t=n)||t.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},l.map((function(e){var t=e.value,n=e.label,i=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:u===t?0:-1,"aria-selected":u===t,key:t,ref:function(e){return c.push(e)},onKeyDown:m,onClick:p},i,{className:(0,o.Z)("tabs__item",g.tabItem,null==i?void 0:i.className,{"tabs__item--active":u===t})}),null!=n?n:t)})))}function k(e){var t=e.lazy,n=e.children,a=e.selectedValue;if(n=Array.isArray(n)?n:[n],t){var o=n.find((function(e){return e.props.value===a}));return o?(0,r.cloneElement)(o,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},n.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})})))}function y(e){var t=h(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",g.tabList)},r.createElement(b,(0,a.Z)({},e,t)),r.createElement(k,(0,a.Z)({},e,t)))}function N(e){var t=(0,v.Z)();return r.createElement(y,(0,a.Z)({key:String(t)},e))}},40484:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return u},metadata:function(){return l},toc:function(){return d}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=(n(74866),n(85162),["components"]),u={id:"custom-routers",title:"Custom routers",sidebar_label:"Custom routers"},s=void 0,l={unversionedId:"custom-routers",id:"version-7.x/custom-routers",title:"Custom routers",description:"The router object provides various helper methods to deal with the state and actions, a reducer to update the state as well as some action creators.",source:"@site/versioned_docs/version-7.x/custom-routers.md",sourceDirName:".",slug:"/custom-routers",permalink:"/docs/7.x/custom-routers",draft:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/custom-routers.md",tags:[],version:"7.x",frontMatter:{id:"custom-routers",title:"Custom routers",sidebar_label:"Custom routers"},sidebar:"version-7.x/docs",previous:{title:"TabActions",permalink:"/docs/7.x/tab-actions"},next:{title:"Custom navigators",permalink:"/docs/7.x/custom-navigators"}},c={},d=[{value:"Built-In Routers",id:"built-in-routers",level:2},{value:"Customizing Routers",id:"customizing-routers",level:2},{value:"Custom Navigation Actions",id:"custom-navigation-actions",level:3},{value:"Blocking Navigation Actions",id:"blocking-navigation-actions",level:3}],p={toc:d},m="wrapper";function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)(m,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The router object provides various helper methods to deal with the state and actions, a reducer to update the state as well as some action creators."),(0,o.kt)("p",null,"The router is responsible for handling actions dispatched by calling methods on the navigation object. If the router cannot handle an action, it can return ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", which would propagate the action to other routers until it's handled."),(0,o.kt)("p",null,"You can make your own router by building an object with the following functions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"type")," - String representing the type of the router, e.g. ",(0,o.kt)("inlineCode",{parentName:"li"},"'stack'"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"'tab'"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"'drawer'")," etc."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getInitialState")," - Function which returns the initial state for the navigator. Receives an options object with ",(0,o.kt)("inlineCode",{parentName:"li"},"routeNames")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"routeParamList")," properties."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getRehydratedState")," - Function which rehydrates the full ",(0,o.kt)("a",{parentName:"li",href:"/docs/7.x/navigation-state"},"navigation state")," from a given partial state. Receives a partial state object and an options object with ",(0,o.kt)("inlineCode",{parentName:"li"},"routeNames")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"routeParamList")," properties."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getStateForRouteNamesChange")," - Function which takes the current state and updated list of route names, and returns a new state. Receives the state object and an options object with ",(0,o.kt)("inlineCode",{parentName:"li"},"routeNames")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"routeParamList")," properties."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getStateForAction")," - function which takes the current state and action along with an options object with ",(0,o.kt)("inlineCode",{parentName:"li"},"routeNames")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"routeParamList")," properties, and returns a new state. If the action cannot be handled, it should return ",(0,o.kt)("inlineCode",{parentName:"li"},"null"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"getStateForRouteFocus")," - Function which takes the current state and key of a route, and returns a new state with that route focused."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"shouldActionChangeFocus")," - Function which determines whether the action should also change focus in parent navigator. Some actions such as ",(0,o.kt)("inlineCode",{parentName:"li"},"NAVIGATE")," can change focus in the parent."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"actionCreators")," - Optional object containing a list of action creators, such as ",(0,o.kt)("inlineCode",{parentName:"li"},"push"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"pop")," etc. These will be used to add helper methods to the ",(0,o.kt)("inlineCode",{parentName:"li"},"navigation")," object to dispatch those actions.")),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const router = {\n  type: 'tab',\n\n  getInitialState({ routeNames, routeParamList }) {\n    const index =\n      options.initialRouteName === undefined\n        ? 0\n        : routeNames.indexOf(options.initialRouteName);\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index,\n      routeNames,\n      routes: routeNames.map(name => ({\n        name,\n        key: name,\n        params: routeParamList[name],\n      })),\n    };\n  },\n\n  getRehydratedState(partialState, { routeNames, routeParamList }) {\n    const state = partialState;\n\n    if (state.stale === false) {\n      return state as NavigationState;\n    }\n\n    const routes = state.routes\n      .filter(route => routeNames.includes(route.name))\n      .map(\n        route =>\n          ({\n            ...route,\n            key: route.key || `${route.name}-${shortid()}`,\n            params:\n              routeParamList[route.name] !== undefined\n                ? {\n                    ...routeParamList[route.name],\n                    ...route.params,\n                  }\n                : route.params,\n          } as Route<string>)\n      );\n\n    return {\n      stale: false,\n      type: 'tab',\n      key: shortid(),\n      index:\n        typeof state.index === 'number' && state.index < routes.length\n          ? state.index\n          : 0,\n      routeNames,\n      routes,\n    };\n  },\n\n  getStateForRouteNamesChange(state, { routeNames }) {\n    const routes = state.routes.filter(route =>\n      routeNames.includes(route.name)\n    );\n\n    return {\n      ...state,\n      routeNames,\n      routes,\n      index: Math.min(state.index, routes.length - 1),\n    };\n  },\n\n  getStateForRouteFocus(state, key) {\n    const index = state.routes.findIndex(r => r.key === key);\n\n    if (index === -1 || index === state.index) {\n      return state;\n    }\n\n    return { ...state, index };\n  },\n\n  getStateForAction(state, action) {\n    switch (action.type) {\n      case 'NAVIGATE': {\n        const index = state.routes.findIndex(\n          route => route.name === action.payload.name\n        );\n\n        if (index === -1) {\n          return null;\n        }\n\n        return { ...state, index };\n      }\n\n      default:\n        return BaseRouter.getStateForAction(state, action);\n    }\n  },\n\n  shouldActionChangeFocus() {\n    return false;\n  },\n};\n\nconst SimpleRouter = () => router;\n\nexport default SimpleRouter;\n")),(0,o.kt)("h2",{id:"built-in-routers"},"Built-In Routers"),(0,o.kt)("p",null,"The library ships with a few standard routers:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"StackRouter")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"TabRouter")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"DrawerRouter"))),(0,o.kt)("h2",{id:"customizing-routers"},"Customizing Routers"),(0,o.kt)("p",null,"You can reuse a router and override the router functions as per your needs, such as customizing how existing actions are handled, adding additional actions etc."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/docs/7.x/custom-navigators"},"custom navigators")," for details on how to override the router with a custom router in an existing navigator."),(0,o.kt)("h3",{id:"custom-navigation-actions"},"Custom Navigation Actions"),(0,o.kt)("p",null,"Let's say you want to add a custom action to clear the history:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { TabRouter } from '@react-navigation/native';\n\nconst MyTabRouter = options => {\n  const router = TabRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      switch (action.type) {\n        case 'CLEAR_HISTORY':\n          return {\n            ...state,\n            routeKeyHistory: [],\n          };\n        default:\n          return router.getStateForAction(state, action, options);\n      }\n    },\n\n    actionCreators: {\n      ...router.actionCreators,\n      clearHistory() {\n        return { type: 'CLEAR_HISTORY' };\n      },\n    },\n  };\n};\n")),(0,o.kt)("p",null,"Instead of writing a custom router to handle custom actions, you can ",(0,o.kt)("a",{parentName:"p",href:"/docs/7.x/navigation-prop#dispatch"},"pass a function to ",(0,o.kt)("inlineCode",{parentName:"a"},"dispatch"))," instead. It's cleaner and recommended instead of overriding routers."),(0,o.kt)("h3",{id:"blocking-navigation-actions"},"Blocking Navigation Actions"),(0,o.kt)("p",null,"Sometimes you may want to prevent some navigation activity, depending on your route. Let's say, you want to prevent pushing a new screen if ",(0,o.kt)("inlineCode",{parentName:"p"},"isEditing")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { StackRouter } from '@react-navigation/native';\n\nconst MyStackRouter = options => {\n  const router = StackRouter(options);\n\n  return {\n    ...router,\n    getStateForAction(state, action, options) {\n      const result = router.getStateForAction(state, action, options);\n\n      if (\n        result != null &&\n        result.index > state.index &&\n        state.routes[state.index].params?.isEditing\n      ) {\n        // Returning the current state means that the action has been handled, but we don't have a new state\n        return state;\n      }\n\n      return result;\n    },\n  };\n};\n")),(0,o.kt)("p",null,"If you want to prevent going back, the recommended approach is to use the ",(0,o.kt)("a",{parentName:"p",href:"/docs/7.x/preventing-going-back"},(0,o.kt)("inlineCode",{parentName:"a"},"beforeRemove")," event"),"."))}f.isMDXComponent=!0}}]);