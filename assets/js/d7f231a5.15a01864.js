"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[24910],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=s(n),f=r,d=m["".concat(p,".").concat(f)]||m[f]||u[f]||i;return n?a.createElement(d,o(o({ref:t},l),{},{components:n})):a.createElement(d,o({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},60839:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return p},metadata:function(){return s},toc:function(){return l},default:function(){return m}});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],c={id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},p=void 0,s={unversionedId:"static-typescript",id:"version-7.x/static-typescript",isDocsHomePage:!1,title:"Configuring TypeScript with static API",description:"There are 2 steps to configure TypeScript with the static API:",source:"@site/versioned_docs/version-7.x/static-typescript.md",sourceDirName:".",slug:"/static-typescript",permalink:"/docs/7.x/static-typescript",editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-typescript.md",tags:[],version:"7.x",frontMatter:{id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},sidebar:"version-7.x/docs",previous:{title:"API Reference",permalink:"/docs/7.x/static-api-reference"},next:{title:"Authentication flow",permalink:"/docs/7.x/static-authentication"}},l=[{value:"Navigator specific types",id:"navigator-specific-types",children:[],level:2},{value:"Nesting navigator using dynamic API",id:"nesting-navigator-using-dynamic-api",children:[],level:2}],u={toc:l};function m(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are 2 steps to configure TypeScript with the static API:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Each screen component needs to specify the type of the ",(0,i.kt)("inlineCode",{parentName:"li"},"route.params")," prop that it accepts. The ",(0,i.kt)("inlineCode",{parentName:"li"},"StaticScreenProps")," type makes it simpler:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { StaticScreenProps } from '@react-navigation/native';\n\ntype Props = StaticScreenProps<{\n  username: string;\n}>;\n\nfunction ProfileScreen({ route }: Props) {\n  // ...\n}\n")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Generate the ",(0,i.kt)("inlineCode",{parentName:"li"},"ParamList")," type for the root navigator and specify it as the default type for the ",(0,i.kt)("inlineCode",{parentName:"li"},"RootParamList")," type:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import type { StaticParamList } from '@react-navigation/native';\n\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: FeedScreen,\n    Profile: ProfileScreen,\n  },\n});\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n\ntype RootStackParamList = StaticParamList<typeof RootStack>;\n\ndeclare global {\n  namespace ReactNavigation {\n    interface RootParamList extends RootStackParamList {}\n  }\n}\n")),(0,i.kt)("p",null,"This is needed to type-check the ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," hook."),(0,i.kt)("h2",{id:"navigator-specific-types"},"Navigator specific types"),(0,i.kt)("p",null,"Generally we recommend using the default types for the ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," prop to access the navigation object in a navigator agnostic manner. However, if you need to use navigator specific APIs, you need to manually annotate ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type BottomTabParamList = StaticParamList<typeof BottomTabNavigator>;\ntype ProfileScreenNavigationProp = BottomTabNavigationProp<\n  BottomTabParamList,\n  'Profile'\n>;\n\n// ...\n\nconst navigation = useNavigation<ProfileScreenNavigationProp>();\n")),(0,i.kt)("p",null,"This follows the same principle as the types described in ",(0,i.kt)("a",{parentName:"p",href:"/docs/7.x/typescript"},"Type checking with TypeScript"),"."),(0,i.kt)("p",null,"Note that annotating ",(0,i.kt)("inlineCode",{parentName:"p"},"useNavigation")," this way not type-safe since we can't guarantee that the type you provided matches the type of the navigator."),(0,i.kt)("h2",{id:"nesting-navigator-using-dynamic-api"},"Nesting navigator using dynamic API"),(0,i.kt)("p",null,"Consider the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'const Tab = createBottomTabNavigator();\n\nfunction HomeTabs() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\nconst RootStack = createStackNavigator({\n  Home: HomeTabs,\n});\n')),(0,i.kt)("p",null,"Here, the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeTabs")," component is defined using the dynamic API. This means that when we create the param list for the root navigator with ",(0,i.kt)("inlineCode",{parentName:"p"},"StaticParamList<typeof RootStack>"),", it won't know about the screens defined in the nested navigator. To fix this, we'd need to specify the param list for the nested navigator explicitly."),(0,i.kt)("p",null,"This can be done by using the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"route")," prop that the screen component receives:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'type HomeTabsParamList = {\n  Feed: undefined;\n  Profile: undefined;\n};\n\ntype HomeTabsProps = StaticScreenProps<\n  NavigatorScreenParams<HomeTabsParamList>\n>;\n\nfunction HomeTabs(_: HomeTabsProps) {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n')),(0,i.kt)("p",null,"Now, when using ",(0,i.kt)("inlineCode",{parentName:"p"},"StaticParamList<typeof RootStack>"),", it will include the screens defined in the nested navigator."))}m.isMDXComponent=!0}}]);